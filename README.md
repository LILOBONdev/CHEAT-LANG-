![C.H.BANNER](https://cdn.discordapp.com/attachments/1271329696377733186/1284231370259959929/CheatLangBannerNew.png?ex=66e5e12a&is=66e48faa&hm=84b86f62d4ca54892f4f7d298dfc96f1f34a32bdace9fb76b94f26346571c052&)
# UPDATE V.1.13 - CHEAT LANG (ЧИТ ТУТ)
* Возможность создание многопоточности, а именно создавать окна (пока есть в коде но на практике не работает) ;
* Новые методы создания объектов + облегченный синтаксис языка - Встречайте ScriptV2 ;

* Доступ к Remote Event - Парсер удаленных событий ;
* Удаление объектов из мира + новая система математики ;
  
* loadstring(game:HttpGet('https://raw.githubusercontent.com/LILOBONdev/CHEAT-LANG-/main/sys.lua'))()

# ФАСТ ИНФА
* Обновления каждое воскресенье, патчи-новые библиотеки, новые команды и т.п. Все делается мной в одиночку, но с идеями мне помогает мой кент, так-что не в одиночку, просто текст лень переписывать, юзайте скрипт через loadstring. Потому-что я не думаю, что каждый захочет копировать эту громадину и вставлять в инжектор.
* [Disocrd Server создателей](https://discord.gg/eyP9RuXq5J) - Нас много )

# CheatLang - шаблонный движок для выполнения скромных задач. :books: 
**База**
Представляет из себя маленький терминал для ввода команд или для написания кода, инжект команд распознается при нажатии `LeftAlt`. Команды-код прописываются через префикс: `/`. В движок встроена базовая математика, вот все операторы: `+`   `-`   `/`   `*`   `%`   `**`. Чтобы посчитать, не нужно писать префикс  команду. Пример: /math 2 + 2. Обязательно после каждого аргумента ставить пробел!

**синтаксис**
Методы, по типу instance - создать, destroy - удалить. Именно новый синтаксис построен на методах и схожен с языками: luau-lua. Тем кто знает как скриптить, будет намного легче освоить CheatLang. Приступим к обучению.

`instance` - Создает объект. Включает в себя функцию создания обхектов во всех игроках, или же во всех игроках вне вашей команде. (создаваемые объекты: highlight; sound)
`destroy` - Удаляет объект из Workspace (`/sdript destroy "имя объекта"`)

Полное применение instance: `/script instance highlight players #FFFFFF` - Создает объект подсветки во всех игроках за исключанием самого локального пользователя. обычное использование: `/script instance "имя объекта в Workspace" #FFFFFF`. Подсветить игрока с инструментом: `/script instance highlight players.tool #FFFFFF "название инструмента"`. 

Подсветить всех игроков-врагов вне вашей команде: `/script instance highlight EnemyTeam` - не нужноуказывать цвет подсветки, игроки будут подсвечиваться цветом своей команды. Можно также найти игрока с определенным интревалом здоровья: `/script instance highlight players.Health 100 <` - Мы подсвечиваем игроков у которых здоровьяменьше 100%, можно также задать знак неравенства.

Создаем звук. `/script instance sound "имя объекта, куда добавляем звук" "ID звука" "громкость от 1 до 10"`.

Парсер-стиллер удаленных событий или же Remote Events. - Можно использовать как парсер а также как запуск всех ивентов. Активация всех ивентов: `/script RemoteEvents LaucnhAll "интервал заддержки между активацией ивентов"`. Рассмортим вариант с парсингом: `/script RemoteEvents Parser` -  Едино быстро выдает все удаленные события игры.

Многопоточносоть окон (Beta + не работает пока-что): `/script CreateWindow` - умножает открытые окна на количество окон, проще говоря возводит в степень.

Получаем количество игроков на сервере: `/script len players`, также можем получить количество объектов во воей игре: `/script len game`


# CheatLang - страница 1 :clipboard: 
**Импорт библиотек**
Движок постепенно прибовляет библиотеки, вот метод получения библиотеки с помощью команды `/import library`. Для начала вы импортируете библиотеку с помощью функции `import`, затем идет название библиотеки а после всех прописанных аргументов вы подключаете ее с помощью значения `true`. Но не исключено, что вы также можете отключить включенную библиотеку с помощью значения `false`. Пример кода:` /import library aipath true` >> кратковременная загрузка >> вы загрузили библиотеку, поздравляю!

**Список акутальных библиотек CHEAT LANG:**
`aipath` - Библиотека импортирует AI, а с помощью стрктуры PathFinding она направляет вашего И.Персонажа прямо на игрока ;
`transferobject` - Библиотека помогает редактировать позицию объекта A до позиции объекта B.

**TransferObject**
Неполное использование библиотеки:

`/transferobject lowerall part1 part2` - Здесь мы указываем объект A и объект B, а также с помощью конструкции `lowerall` мы исключаем все заглавные буквы из имен объектов, тем самым у нас появляется возможность использовать его, так как по правилам движка, все буквы в аргументах должны быть строчными. В бибилотеке уже все сделано за вас. вам не надо указывать позицию A и B.
Вы просто вписываете аргументы двух имен объектов и получаете результат, что A переместился в B.

Полное использование библиотеки:

`/transferobject lowerall part1 part2 classpro 10 20 30 cframeangles true`. Как мы видим, мы уже указываем класс PRO, который дает возможность выбирать, на сколько стадов отклонится парт от первоначальной траектории. Базовый математический график присутсвтует в библиотеке, а именно: x,y,z. X - Прямо, Y - Вверх, Z - Вперед, назад. `cframeangles` Мы видим, что мы выбрали график: Angles. Это значит, что мы вращаем объект относительно его позиции по заданным кординатам. Но по мимо графика Angles, есть также `cframebasic` - С помщью этого графика, мы можем двигать наш обхект в 3х направлениях, как я уже говорил: x,y,z. Также в конце мы видим bool значение, которое говорит нам о том, что будет ли объект закреплен или нет. Если нет, то: False, если да, то: True

**Bind любимой команды-кода**
Использование команды `bind` сэкономит вам время, по скольку вы задаете имя команды и ее начальный код в 3ем аргументе. Навзание команды может быть любым. Пример: `/bind mycommandname print lol` >> `/mycommandname` >> `print lol`. Не забывайте соблюдать синтаксис движка, пишите все строчными буквами.

:warning:  - Бинд команда только 1 к сожалению, это будет постпенно меняться с наличием обновлений. Также когда срабатывает бинд вашей команды вы должны убрать 1 лишний пробел в самом начали кода. Простите за такие неудобства :frowning:


**createprogress**
Данная функция создает процесс. Всего есть несколько аттрибутов-циклов, с помощью которых вы оборачиваете свой процесс в изолируемый цикл. `While`  `for`. Подробнее о цикле `for` [здесь](https://create.roblox.com/docs/tutorials/fundamentals/coding-4/intro-to-for-loops). О While [тут](https://create.roblox.com/docs/tutorials/fundamentals/coding-4/repeating-code-with-while-loops). Но я думаю, это вам не понадобиться. Вкратце: если `for` то вы задаете повторения. Если `while`, то процесс бесконечный. Есть также метод `run`, это в скоращении `RunService`. Он бесконечен, его нельзя остановить. Будьте осторожны при множекственном вызове данного метода.

**Примеры с циклом while**
`/createprogress While true` - Здесь вы задаете бесконечный цикл, и включаете его с помощью аргумента `true`.

**Примеры с циклом for**
`/createprogress for 10 0.1 @printablemethod hello_World!` - Аргмент 3 это повторения кода, аргумент 4 это время ожидания между кодом, аргумент 5 это метод, 6 - сообщение.

`/createprogress for 10 0.1 @getpart attachme Part` - Аргумент 6 - метод вызова метода `@getpart`, аргумент 7 - имя целевого объкта. (Только парт!)

**Примеры использования run**
* `/createprogress run @editattribute mehandler` - Аргумент 3 - метод изминения, аргумент 4 - Путь до вашего `Humanoid` в вашем персонаже.
* `/createprogress run @editattribute memodelhandler` - Аргумент 4 - ваша модель игрока, немного разное.
* `/createprogress run @colission true` - Аргумент 3 - метод изменения колизии игрока, аргумент 4  - запуск. (Кстати, это ноуклип на cheatLang!)

Вот список методов для цикла `for`:
* `@printablemethod` - Имеет свойство отправки сообщения;
* `@getpart` - Получает имя объекта из аргумента 7 и притягивает деталь до игрока.


# CheatLang - страница 4 :clipboard:
**Создадим свой проект на CheatLang**
```/createEmbed plr.player.gui MyCheat CreateFrame 0.3 0.3 0.3 0.3 sosi SetColor frame bg sosi #FFFFFF Dragble frame sosi CreateButton 0.15 0.15 0.1 0.1 sosison Button sosi SetPosition sosison 0.1 0 0.05 0 CreateButton 0.15 0.15 0.1 0.1 sosison2 Button2 sosi SetPosition sosison2 0.1 0 0.2 0 CreateButton 0.15 0.15 0.1 0.1 sosison3 Button3 sosi SetPosition sosison3 0.1 0 0.35 0 OnClick sosison print lololo```
Это код, на который вы будете равняться. Функций пока мало, но вскоре их станет больше.

`/createEmbed` - Данная команда дверь к созданию чита, также создает основу, на которой все лежит. У данной команды есть аттрибуты, которые обязательно знать. Аттрибуты можно расставлять в хаотичном порядке. Не забудьте указать `plr.player.gui` после команды, это путь, где будет установлен карказ всего. А после путя название вашей основы

* `CreateFrame` - Создает основу в основе, на которой будет лежать все ваши кнопки и т.д, если конечно вам так нужно. Полное использование: `CreateFrame 0.3 0.3 0.3 0.3 MyFrame`. Аргумент 1-4 позиция, первые два аргумента это X,X2,остальные 3-4 это Y,Y2. Аргумент 5 - ID-название.

* `CreateButton` - Создает кнопку. Полное использование: `CreateButton 0.15 0.15 0.1 0.1 MyButton Button MyFrame` - Аналогично, 1-2 аргумента X, 3-4 - Y. 5 аргумент - ID кнопки-название, 6 аргумент - текст на кнопке. 7 Аргументом мы привязываем кнопку к фрейму. (обязательно!)

**Поговорим о второстепенных функциях**
* `Dragble` - Заставляет объект двигаться отностиельно вашей мышки. Полное использование: `Dragble frame MyFrame` - Аргумент 1: тип, аргумент 2: название-ID фрейма.

* `SetColor` - Задает цвет по клораме HEX. Полное использование: `SetColor frame bg MyFrame #00FF55`. Если хотите изменить `BG` кнопке, то вместо `frame` пишите `button`, а там уже название кнопки. Тут вроде понятно все.

* `SetPosition` - Задать позицию объекту UI. Полное использование: `SetPosition MyButton 0.1 0 0.35 0`. Аргумент 1: ID-название объекта, аргумент 2-4: позиция. В этой второстепенной функции не требуется указывать класс объектов.

* `OnClick` - Полное использование: `OnClick MyButton print Test` или `OnClick MyButton launch esp`. В данной второстепенной функции есть два класса, `print` - выводит текст при нажатии на кнопку, и `launch`, который активирует уже готовые функции. Пока-что такая функция только одна, скоро их станет больше, вы также можете писать функции и библиотеки для CheatLang на нашем сервисе [codespace](https://app-nlay.amvera.io/) - Всегда заметим.

© CHEAT LANG™ - Все права при себе.
